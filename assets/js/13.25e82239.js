(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{495:function(t,e,n){"use strict";n.r(e);var a=n(4),i=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"深入学习垃圾回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深入学习垃圾回收"}},[t._v("#")]),t._v(" 深入学习垃圾回收")]),t._v(" "),n("h2",{attrs:{id:"_1-如何判断对象可以回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何判断对象可以回收"}},[t._v("#")]),t._v(" 1.如何判断对象可以回收")]),t._v(" "),n("p",[t._v("这里有两种不同的算法。")]),t._v(" "),n("h3",{attrs:{id:"_1-1-引用计数法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-引用计数法"}},[t._v("#")]),t._v(" 1.1 引用计数法")]),t._v(" "),n("p",[t._v("只要一个对象被其他变量所引用，那么我们就让这个计数+1。如果引用2次，就+2。\n如果一个变量不再引用它了，就-1。当计数变为0的时候，那么这个对象就可以作为垃圾被回收。")]),t._v(" "),n("p",[t._v("但是引用计数法有一个严重的弊端，那就是"),n("strong",[t._v("循环引用")]),t._v("。看下图：\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583034898103-c85bdb2d-ec55-4ba7-bd52-fa5838b5efb3.png#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200301115001.png&originHeight=227&originWidth=482&size=56605&status=done&style=none&width=332",alt:"QQ图片20200301115001.png"}}),t._v("\nA对象引用了B对象，A的引用计数为1。B对象引用了A对象，B的引用计数为1。除此之外，这两个对象再无任何引用。\n事实上，这两个对象已经不可能再被访问。但是因为它们互相引用着对方，导致它们的引用计数都不为0，所以引用计数法无法通知GC收集器回收它们。这样就会造成内存上的泄露。")]),t._v(" "),n("h3",{attrs:{id:"_1-2-可达性分析算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-可达性分析算法"}},[t._v("#")]),t._v(" 1.2 可达性分析算法")]),t._v(" "),n("p",[t._v("可达性分析算法首先要确定一系列"),n("strong",[t._v("根对象（GC Roots）")]),t._v("。")]),t._v(" "),n("p",[n("strong",[t._v("什么是根对象？")]),t._v("\n先可以这样理解，根对象就是那些肯定不能当成垃圾被回收的对象。")]),t._v(" "),n("p",[t._v("在垃圾回收之前，我们首先会对堆内存中的所有对象进行一遍扫描。然后看看每一个对象是否被刚才提到的根对象直接或间接的引用。如果是，那么这个对象就不能被回收，反之这个对象就可以被作为垃圾回收。\nGC管理的主要区域是"),n("strong",[t._v("Java堆")]),t._v("，一般情况下只针对堆进行垃圾回收。"),n("strong",[t._v("方法区")]),t._v("、"),n("strong",[t._v("栈")]),t._v("和"),n("strong",[t._v("本地方法区")]),t._v("不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。")]),t._v(" "),n("p",[n("strong",[t._v("哪些对象可以被作为GC Roots呢？")])]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("System Class（系统类）")])])]),t._v(" "),n("p",[n("strong",[t._v("这些类都是由类加载器加载的类。")])]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("Native Stack")])])]),t._v(" "),n("p",[n("strong",[t._v("虚拟机在调用方法时会调用一些操作系统方法，操作系统方法在运行时所引用的java对象肯定时不能回收的。")])]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("Busy Monitor")])])]),t._v(" "),n("p",[n("strong",[t._v("正在加锁的对象也可以作为根对象。")])]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("Thread")])])]),t._v(" "),n("p",[n("strong",[t._v("活动中的线程肯定不能被当成垃圾回收。线程内每次方法调用都会产生一个栈帧，那么栈帧内所引用的对象就可以当作根对象。")])]),t._v(" "),n("h3",{attrs:{id:"_1-3-四种引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-四种引用"}},[t._v("#")]),t._v(" 1.3 四种引用")]),t._v(" "),n("p",[t._v("严格来讲，不止4种引用。")]),t._v(" "),n("ol",[n("li",[t._v("强引用（strong reference）")]),t._v(" "),n("li",[t._v("软引用（soft reference）")]),t._v(" "),n("li",[t._v("弱引用")]),t._v(" "),n("li",[t._v("虚引用")]),t._v(" "),n("li",[t._v("终结器引用")])]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583066116104-71da1b14-ba44-491d-9388-968f1fb088c9.png#align=left&display=inline&height=543&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200301203502.png&originHeight=543&originWidth=1022&size=234945&status=done&style=none&width=1022",alt:"QQ图片20200301203502.png"}})]),t._v(" "),n("ul",[n("li",[t._v("**强引用（Strongly Reference）**是最传统的引用的定义。是指在程序中普遍存在的引用赋值，就是类似 "),n("code",[t._v("Object obj = new Object( )")]),t._v(" 这种引用关系。")]),t._v(" "),n("li",[t._v("**软引用（Soft Reference）**是用来描述一些还有用但是并非必须的对象。比如图中C对象间接引用了A2对象。对于软引用关联着的对象，在系统发生内存溢出异常之前，会把这些对象列入回收范围进行第二次回收。如果内存还不够，才会抛出内存溢出异常。")]),t._v(" "),n("li",[t._v("**弱引用（Weak Reference）**也是用来描述非必须对象的。不过它的强度比软引用弱一些。被弱引用关联着的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作后，无论当前内存是否充足，都会回收掉被弱引用关联着的对象。")]),t._v(" "),n("li",[t._v("**虚引用（Phantom Reference）**是最弱的一种引用关系。一个对象是否有虚引用完全不会对其生存时间构成影响。当然也无法通过虚引用获得对象实例。为对象设置虚引用的唯一目的就是在这个对象被回收时收到一个系统通知。")])]),t._v(" "),n("h2",{attrs:{id:"_2-垃圾回收算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-垃圾回收算法"}},[t._v("#")]),t._v(" 2.垃圾回收算法")]),t._v(" "),n("h3",{attrs:{id:"_2-1-标记-清除算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-标记-清除算法"}},[t._v("#")]),t._v(" 2.1 标记-清除算法")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583221987826-811a510a-6991-492b-83af-81d44e99bcd6.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200303155134.png&originHeight=224&originWidth=419&size=39779&status=done&style=none&width=419",alt:"QQ图片20200303155134.png"}}),t._v(" "),n("strong",[t._v("第一阶段--标记")]),t._v("：\n先标记哪些垃圾可以被回收的。（那些没被GC Root引用的对象就是可回收的）\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583222101376-706ab95f-76a9-479e-b3fb-bc1842d81965.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200303155431.png&originHeight=222&originWidth=416&size=38698&status=done&style=none&width=425",alt:"QQ图片20200303155431.png"}}),t._v("图中灰色的就是可以回收的对象\n"),n("strong",[t._v("第二阶段--清除")]),t._v("：\n清除就是把这些垃圾对象所占用的内存空间进行释放。而且只需要记住内存空间的起始和结束地址就可以清楚，所以说速度很快。 \n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583222280837-e85948c9-5e90-496e-8f2e-4776b2f150ae.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200303155751.png&originHeight=219&originWidth=402&size=32089&status=done&style=none&width=416",alt:"QQ图片20200303155751.png"}})]),t._v(" "),n("p",[n("strong",[t._v("缺点")]),t._v("：\n会"),n("strong",[t._v("产生大量不连续的内存碎片")]),t._v("。当要分配一个较大的对象时，无法找到足够的连续内存时，又会触发一次垃圾收集动作，所以说效率不高。")]),t._v(" "),n("h3",{attrs:{id:"_2-2-标记-整理算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-标记-整理算法"}},[t._v("#")]),t._v(" 2.2 标记-整理算法")]),t._v(" "),n("p",[n("strong",[t._v("第一阶段--标记")]),t._v("：\n标记阶段跟标记清除算法是一样的做法。\n"),n("strong",[t._v("第二阶段--整理")]),t._v("：\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583223516351-94584289-ebeb-4ae6-a2e7-17e95941da22.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200303161752.png&originHeight=221&originWidth=482&size=32208&status=done&style=none&width=482",alt:"QQ图片20200303161752.png"}}),t._v("\n在整理阶段，不是直接对可回收对象进行清理，而是让所有的存活对象都向一端移动，然后直接清理掉端边界以外的内存。\n"),n("strong",[t._v("缺点")]),t._v("：\n整理会牵扯到对象地址的移动，所以效率会不高。")]),t._v(" "),n("h3",{attrs:{id:"_2-3-标记-复制算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-标记-复制算法"}},[t._v("#")]),t._v(" 2.3 标记-复制算法")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583224274670-198a5e5c-2bba-4199-adbe-bbd8c55ef299.png#align=left&display=inline&height=293&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200303163105.png&originHeight=293&originWidth=740&size=47166&status=done&style=none&width=740",alt:"QQ图片20200303163105.png"}}),t._v("\n该算法将可用内存划分为大小相等的两块，每次只使用其中的一块。我们把左边这个区域称为from,把右边这个区域成为to。\n首先一样标记出可回收的对象。把from区域存活着的对象复制到to区域，然后把from区域一次性清理掉。"),n("strong",[t._v("最后交换from区域和to区域")]),t._v("。\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583224471914-ec32dc89-7b21-4591-afdd-1ec4adc8e50c.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200303163423.png&originHeight=224&originWidth=726&size=39919&status=done&style=none&width=726",alt:"QQ图片20200303163423.png"}}),t._v(" "),n("strong",[t._v("缺点")]),t._v("：\n将可用内存缩小为了原来的一半，空间浪费有点多。")]),t._v(" "),n("h2",{attrs:{id:"_3-分代回收机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-分代回收机制"}},[t._v("#")]),t._v(" 3.分代回收机制")]),t._v(" "),n("h3",{attrs:{id:"_3-1-对象优先在eden区分配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-对象优先在eden区分配"}},[t._v("#")]),t._v(" 3.1 对象优先在Eden区分配")]),t._v(" "),n("p",[t._v("虚拟机不会单独地采用一种算法，而是灵活地采用几种算法协调工作。"),n("strong",[t._v("具体实现的方法就是分代垃圾回收机制")]),t._v("。\n它把整个堆内存划分了两个区域，一个叫"),n("strong",[t._v("新生代")]),t._v("，一个叫"),n("strong",[t._v("老年代")]),t._v("。")]),t._v(" "),n("p",[t._v(":::info\n"),n("strong",[t._v("为什么要把堆内存划分成这两个区域呢？")]),t._v(" "),n("strong",[t._v("Java中有的对象需要长时间使用，这些对象就放在老年代中。而那些用完就可以丢弃的对象，就可以放在新生代中。")]),t._v(" "),n("strong",[t._v("不同的区域采用不同的算法，会使得垃圾回收的效率更高。")]),t._v("\n:::")]),t._v(" "),n("p",[t._v("新生代又划分了几个具体区域：Eden区、幸存区from、幸存区to\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583226154443-d3038ae7-b6a4-4548-9d2e-39b9dae8b31a.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200303170228.png&originHeight=255&originWidth=544&size=37189&status=done&style=none&width=404",alt:"QQ图片20200303170228.png"}}),t._v("\n当我们创建一个新的对象时，这个新的对象就会被分配到一个叫"),n("strong",[t._v("伊甸园（Eden区）"),n("strong",[t._v("的空间。当Eden区没有足够空间进行分配时，就会触发一次垃圾回收。新生代的垃圾回收我们一般都叫它----"),n("strong",[t._v("Minor GC")]),t._v("。\nPS：Minor GC会引发stop the  world，暂停其他用户线程。等GC结束，其他用户线程才恢复运行。\n接着就开始标记可回收对象，当标记成功之后，这里就会采用复制算法，将存活的对象复制到幸存区To中。并且让这些存活的对象寿命+1。\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583464896889-a70a46df-1103-4f0d-82fd-40808a82bea8.png#align=left&display=inline&height=153&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200306112127.png&originHeight=153&originWidth=123&size=11870&status=done&style=none&width=123",alt:"QQ图片20200306112127.png"}}),t._v("\n最后")]),t._v("交换幸存区From和幸存区To的位置（注意，这里交换的是引用）")]),t._v("。这样伊甸园的空间又充足了，又可以放新的对象了。\n过一段时间，伊甸园对象又满了，就会触发第二次垃圾回收。这次除了标记伊甸园的可回收对象，也要标记幸存区From区域中的存活对象，然后将存活对象放入幸存区To中，并且寿命加1。最后再和幸存区From区域交换。\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583465451197-00accc48-88bc-437d-a6d3-9a36936d5a30.png#align=left&display=inline&height=172&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200306113043.png&originHeight=172&originWidth=215&size=21417&status=done&style=none&width=215",alt:"QQ图片20200306113043.png"}})]),t._v(" "),n("p",[t._v("对象不可能一直呆在幸存区中，如果幸存区中的对象寿命超过了一定的阈值("),n("strong",[t._v("这个阈值一般最大是15次：4个bit")]),t._v("），说明这个对象具有更高的价值。那我们就把他晋升到"),n("strong",[t._v("老年代")]),t._v("去。")]),t._v(" "),n("p",[n("strong",[t._v("如果老年代也快放满了，这时在创建对象会触发什么呢？")]),t._v("\n这时会先触发一次Minor GC，如果空间还不足，这时就会触发一次"),n("strong",[t._v("Full GC")]),t._v("。对整个内存空间进行一次清理。如果回收完空间仍不足，就会报错"),n("strong",[t._v("OutOfMemory")]),t._v("。")]),t._v(" "),n("h3",{attrs:{id:"_3-2-长期存活的对象将进入老年代"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-长期存活的对象将进入老年代"}},[t._v("#")]),t._v(" 3.2 长期存活的对象将进入老年代")]),t._v(" "),n("p",[t._v("虚拟机给每个对象定义了一个对象年龄计数器。对象在幸存区每熬过一次MinorGC，年龄就增加一岁。当年龄增加到一定程度（默认是15），就会被晋升到老年代。")]),t._v(" "),n("h3",{attrs:{id:"_3-2-相关虚拟机参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-相关虚拟机参数"}},[t._v("#")]),t._v(" 3.2 相关虚拟机参数")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"center"}},[n("strong",[t._v("含义")])]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[n("strong",[t._v("参数")])]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("注释")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("堆初始大小")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-Xms")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("堆最大大小")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-Xmx或-XX:MaxHeapSize=size")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("新生代大小")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-Xmn或-XX:NewSize=size +")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:MaxNewSize=size")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}}),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("幸存区比例（动态）")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:InitialSurvivorRatio=ratio和")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+UseAdaptiveSizePolicy")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("前面的是初始化幸存区的大小，后面是动态比例调整的开关")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("幸存区比例")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:Survivor-Ratio:ratio")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("晋升阈值")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:MaxTenuringThreadsold=threadsold")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("寿命如果超过一定的阈值，就会从新生代晋升到老年代")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("晋升详情")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+PrintTenuringDistribution")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("GC详情")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+PrintGCDetails -verbose:gc")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("FullGC前MinorGC")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+ScavengeBeforeFullGC")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("是一个开关：是否在FullGC前做一次新生代的MinorGC")])])])]),t._v(" "),n("h3",{attrs:{id:"_3-3-空间分配担保机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-空间分配担保机制"}},[t._v("#")]),t._v(" 3.3 空间分配担保机制")]),t._v(" "),n("p",[t._v("在发生MinorGC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果成立，这一次MinorGC是可以确保安全的。")]),t._v(" "),n("h2",{attrs:{id:"_4-垃圾收集器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-垃圾收集器"}},[t._v("#")]),t._v(" 4.垃圾收集器")]),t._v(" "),n("h3",{attrs:{id:"_4-1-serial收集器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-serial收集器"}},[t._v("#")]),t._v(" 4.1 Serial收集器")]),t._v(" "),n("blockquote",[n("p",[t._v("串行收集器")])]),t._v(" "),n("p",[t._v("从名字可以看出，该收集器是一个单线程工作的收集器。更重要的是，在它进行垃圾收集时，必须“"),n("strong",[t._v("stop the world")]),t._v("”，也就是暂停其他所有工作线程。")]),t._v(" "),n("ul",[n("li",[t._v("优点：简单而高效。")])]),t._v(" "),n("h3",{attrs:{id:"_4-2-parnew收集器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-parnew收集器"}},[t._v("#")]),t._v(" 4.2 ParNew收集器")]),t._v(" "),n("blockquote",[n("p",[t._v("ParNew收集器实质上时Serial收集器的多线程并行版本")])]),t._v(" "),n("h3",{attrs:{id:"_4-3-parallel-scavenge收集器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-parallel-scavenge收集器"}},[t._v("#")]),t._v(" 4.3 Parallel Scavenge收集器")]),t._v(" "),n("blockquote",[n("p",[t._v("也被称作吞吐量优先的垃圾收集器")])]),t._v(" "),n("h3",{attrs:{id:"_4-3-响应时间优先的垃圾回收器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-响应时间优先的垃圾回收器"}},[t._v("#")]),t._v(" 4.3 响应时间优先的垃圾回收器")]),t._v(" "),n("ul",[n("li",[t._v("多线程")]),t._v(" "),n("li",[t._v("堆内存较大的情况，多核CPU")]),t._v(" "),n("li",[t._v("在垃圾回收时，让stop the world的单次时间尽可能地短 0.1 0.1 0.1 0.1 0.1 = 0.5")])]),t._v(" "),n("h3",{attrs:{id:"_4-4-g1垃圾收集器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-g1垃圾收集器"}},[t._v("#")]),t._v(" 4.4 G1垃圾收集器")]),t._v(" "),n("p",[t._v("G1是一款面向服务端应用的垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间，同时还能保持较高的吞吐量。\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583499149527-4558657f-c823-45af-a19e-c90285c4b029.png#align=left&display=inline&height=297&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200306205220.png&originHeight=495&originWidth=602&size=163142&status=done&style=none&width=361",alt:"微信图片_20200306205220.png"}}),t._v("\nG1垃圾收集器分为了3个阶段，如图所示。这个过程是一个循环的过程。")]),t._v(" "),n("h4",{attrs:{id:"_1-young-collection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-young-collection"}},[t._v("#")]),t._v(" 1) Young Collection")]),t._v(" "),n("h4",{attrs:{id:""}},[n("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")]),t._v(" "),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583499661255-0a8d2102-1f36-49d6-a4fd-d248752d4a00.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200306210051.png&originHeight=439&originWidth=593&size=62961&status=done&style=none&width=405",alt:"微信图片_20200306210051.png"}})]),t._v(" "),n("p",[t._v("G1的内存空间结构跟传统的有所不同，它将整个堆内存空间划分为大小相等的内存区域"),n("strong",[t._v("Region")]),t._v("（"),n("strong",[t._v("默认是512k")]),t._v("）。每个区域都可以是伊甸园，幸存区，老年代。"),n("strong",[t._v("这些区域在物理内存地址上是不连续的，但在逻辑上是连续的。")])]),t._v(" "),n("p",[t._v("当伊甸园的内存空间用完时，就会触发一次新生代回收（Young Collection）。也会触发"),n("strong",[t._v("STW")]),t._v("。\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583500366889-3bb5d65f-7f7e-4a35-8a54-681321f352bf.png#align=left&display=inline&height=251&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200306211206.png&originHeight=425&originWidth=568&size=78530&status=done&style=none&width=336",alt:"微信图片_20200306211206.png"}}),t._v("\n新生代回收就会把存活的对象以"),n("strong",[t._v("复制的算法")]),t._v("拷贝到幸存区。\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583500457141-56ce896e-44e4-4bc8-9fb9-58cb096a3e0b.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200306211406.png&originHeight=427&originWidth=567&size=91048&status=done&style=none&width=318",alt:"微信图片_20200306211406.png"}}),t._v("\n在工作一段时间，幸存区的对象也比较多了，有的对象寿命超过一定阈值，又会触发一次新生代垃圾回收。将寿命长的对象晋升到老年代。")]),t._v(" "),n("h4",{attrs:{id:"_2-young-collection-cm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-young-collection-cm"}},[t._v("#")]),t._v(" 2) Young Collection + CM")]),t._v(" "),n("p",[t._v("接下来就到第二阶段：新生代回收+并发标记阶段（Concurrent Marking）")]),t._v(" "),n("ul",[n("li",[t._v("在Young GC新生代垃圾回收时，会先对GC Root进行初始标记，不会占用并发标记的时间。初始标记仅仅只是标记一下GC Roots能直接关联到的对象。")]),t._v(" "),n("li",[t._v("老年代占用堆比例达到一定阈值时，会进行并发标记（不会STW）。阈值由下面的JVM参数决定：")])]),t._v(" "),n("p",[n("strong",[n("code",[t._v("－XX:InitiatingHeapOccupancyPercent=percent")])]),t._v(" （默认是45%）")]),t._v(" "),n("h4",{attrs:{id:"_3-mixed-collection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-mixed-collection"}},[t._v("#")]),t._v(" 3) Mixed Collection")]),t._v(" "),n("p",[t._v("G1垃圾回收阶段的第三个阶段：混合收集\n该阶段会回收所有新生代的region和"),n("strong",[t._v("部分老年代的Region")]),t._v("。\n"),n("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/616319/1583545704659-b7f18f1f-f495-473e-9763-ca7b7147343b.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720200307094722.png&originHeight=469&originWidth=616&size=117505&status=done&style=none&width=442",alt:"QQ图片20200307094722.png"}}),t._v("\n在图中可以看出，还有的老年代经过并发标记后，幸存的对象也会用复制算法复制到新的老年代去。\n而且G1收集器会有选择地对老年代进行回收。他会优先回收那些回收价值较高的老年代对象。回收这些对象释放的内存空间比较多。")])])}),[],!1,null,null,null);e.default=i.exports}}]);