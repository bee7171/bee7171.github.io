(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{493:function(a,s,t){"use strict";t.r(s);var _=t(4),r=Object(_.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"_1-类文件结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-类文件结构"}},[a._v("#")]),a._v(" 1.类文件结构")]),a._v(" "),t("h2",{attrs:{id:"_2-类加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-类加载"}},[a._v("#")]),a._v(" 2.类加载")]),a._v(" "),t("h3",{attrs:{id:"_2-1-加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-加载"}},[a._v("#")]),a._v(" 2-1.加载")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("查找并加载类文件的二进制数据。")]),a._v(" "),t("ol",[t("li",[a._v("通过类的全限定名来获取到类的二进制字节流。")]),a._v(" "),t("li",[a._v("把二进制字节流转换为"),t("strong",[a._v("方法区的运行时数据结构")]),a._v("。")]),a._v(" "),t("li",[a._v("在堆上创建一个"),t("code",[a._v("java.lang.Class")]),a._v("对象，用来"),t("strong",[a._v("封装")]),a._v("类在方法区的数据结构。并"),t("strong",[a._v("向外提供")]),a._v("了访问方法区内数据结构的接口。")])])]),a._v(" "),t("li",[t("strong",[a._v("加载类的方式：")]),a._v(" "),t("ul",[t("li",[a._v("**最常见的方式：**本地文件系统中加载，从jar等归档文件中加载。")]),a._v(" "),t("li",[a._v("**动态方式：**将java源文件动态编译成class。")]),a._v(" "),t("li",[a._v("**其他方式：**网络下载，从专有数据库加载等等。")])])])]),a._v(" "),t("h3",{attrs:{id:"_2-2-连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-连接"}},[a._v("#")]),a._v(" 2-2.连接")]),a._v(" "),t("p",[a._v("连接就是把已经读入内存的二进制数据合并到JVM的运行时环境中去。")]),a._v(" "),t("p",[t("strong",[a._v("连接又可以分为3个阶段：")])]),a._v(" "),t("ul",[t("li",[a._v("**验证：**验证类是否符合JVM规范，并进行安全性检查。（"),t("strong",[a._v("确保被加载类的正确性")]),a._v("）")]),a._v(" "),t("li",[a._v("**准备：**为"),t("code",[a._v("static")]),a._v("变量分配内存空间，并初始化它们。")])]),a._v(" "),t("div",{staticClass:"language-markdown line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-markdown"}},[t("code",[a._v("注意1：static变量分配空间和赋值是两个步骤。分配空间和初始化在准备阶段完成，而赋值则在初始化阶段完成。\n\t\n注意2：如果是final修饰的static变量的基本类型以及字符串常量，那么赋值在准备阶段就完成了。\n\n注意3：如果是final修饰的static变量的引用类型，那么赋值会在初始化阶段完成。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("ul",[t("li",[a._v("**解析：**将常量池中的符号引用解析为直接引用。")])]),a._v(" "),t("div",{staticClass:"language-markdown line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-markdown"}},[t("code",[a._v("符号引用：\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h3",{attrs:{id:"_2-1-初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-初始化"}},[a._v("#")]),a._v(" 2-1.初始化")]),a._v(" "),t("ul",[t("li",[a._v("为类的静态变量赋初始值。")])]),a._v(" "),t("h2",{attrs:{id:"_3-类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-类加载器"}},[a._v("#")]),a._v(" 3.类加载器")]),a._v(" "),t("div",{staticClass:"language-markdown line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-markdown"}},[t("code",[a._v("什么是类加载器？\n\t 通过一个类的全限定名来获取该类的二进制字节流。实现这个动作的代码就称为类加载器。\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[t("strong",[a._v("JVM自带的加载器有如下几种：")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("Bootstrap ClassLoader")]),a._v("启动类加载器。")]),a._v(" "),t("li",[t("code",[a._v("Platform ClassLoader")]),a._v("平台类加载器。\n"),t("ul",[t("li",[a._v("在JDK8中是"),t("code",[a._v("Extension ClassLoader")]),a._v("扩展类加载器，9以后被替换掉了。")])])]),a._v(" "),t("li",[t("code",[a._v("AppClassLoader")]),a._v("应用程序类加载器。")])]),a._v(" "),t("p",[t("strong",[a._v("还有一种是用户自定义的类加载器。是"),t("code",[a._v("java.lang.ClassLoader")]),a._v("的子类。")])]),a._v(" "),t("p",[a._v("​\t\t\t用户可以自定义类的加载方式，但是自定义类加载器其加载的顺序在所有系统的类加载器的最后。")]),a._v(" "),t("h3",{attrs:{id:"_3-1-类加载器的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-类加载器的关系"}},[a._v("#")]),a._v(" 3-1.类加载器的关系")]),a._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://bee71-1302549720.cos.ap-shanghai.myqcloud.com/Snipaste_2020-08-23_14-56-12.png"}}),a._v(" "),t("p",[t("img",{attrs:{src:"https://bee71-1302549720.cos.ap-shanghai.myqcloud.com/Snipaste_2020-08-16_17-35-14.png",alt:""}})]),a._v(" "),t("p",[a._v("上图就是类加载器的层级分级。为什么要分成这几个类加载器呢？")]),a._v(" "),t("h3",{attrs:{id:"双亲委派模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型"}},[a._v("#")]),a._v(" 双亲委派模型")]),a._v(" "),t("ul",[t("li",[a._v("JVM中的"),t("code",[a._v("CLassLoader")]),a._v("通常采用双亲委派模型。要求除了启动类加载器以外，其余的类加载器都应该有自己的父级加载器。"),t("strong",[a._v("这里的父子关系是组合而不是继承。")])]),a._v(" "),t("li")])])}),[],!1,null,null,null);s.default=r.exports}}]);