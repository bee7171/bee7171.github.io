(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{541:function(a,t,r){"use strict";r.r(t);var e=r(4),_=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"concurrenthashmap和copyonwritearraylist"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap和copyonwritearraylist"}},[a._v("#")]),a._v(" ConcurrentHashMap和CopyOnWriteArraylist")]),a._v(" "),r("ul",[r("li",[a._v("取代同步的"),r("code",[a._v("HashMap")]),a._v("和"),r("code",[a._v("ArratList")]),a._v("。")])]),a._v(" "),r("h2",{attrs:{id:"concurrenthashmap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),r("h3",{attrs:{id:"_1-为什么需要concurrenthashmap？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么需要concurrenthashmap？"}},[a._v("#")]),a._v(" 1.为什么需要ConcurrentHashMap？")]),a._v(" "),r("div",{staticClass:"language-markdown line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-markdown"}},[r("code",[a._v("为什么不适用Collections.synchronizedMap()?\n\t\t它是通过一把锁来实现并发安全访问的，并发量高的时候，性能并不理想。\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br"),r("span",{staticClass:"line-number"},[a._v("2")]),r("br")])]),r("h3",{attrs:{id:"_2-为什么hashmap是线程不安全的？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么hashmap是线程不安全的？"}},[a._v("#")]),a._v(" 2.为什么HashMap是线程不安全的？")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("同时put碰撞会造成数据丢失。")])]),a._v(" "),r("li",[r("p",[a._v("同时put扩容会导致数据丢失。")])]),a._v(" "),r("li",[r("p",[a._v("死循环造成的CPU100%。")])])]),a._v(" "),r("h3",{attrs:{id:"_3-put方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-put方法"}},[a._v("#")]),a._v(" 3.put方法")]),a._v(" "),r("h3",{attrs:{id:"为什么要把1-7改成1-8的结构？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要把1-7改成1-8的结构？"}},[a._v("#")]),a._v(" 为什么要把1.7改成1.8的结构？")]),a._v(" "),r("h2",{attrs:{id:"阻塞队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[a._v("#")]),a._v(" 阻塞队列")]),a._v(" "),r("p",[r("strong",[a._v("最典型的用法：就是生产者消费者模式里的阻塞队列。")])]),a._v(" "),r("h3",{attrs:{id:"_1-阻塞队列基本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-阻塞队列基本概念"}},[a._v("#")]),a._v(" 1.阻塞队列基本概念")]),a._v(" "),r("p",[r("strong",[a._v("最有特色的两个方法：")])]),a._v(" "),r("p",[r("code",[a._v("take()")]),a._v("：获取并且移除队列里的头结点。但如果队列里无数据，则阻塞，直到有数据。")]),a._v(" "),r("p",[r("code",[a._v("put()")]),a._v("：插入元素，但如果队列已满，则无法继续插入。直到队列有空闲空间。")]),a._v(" "),r("p",[r("strong",[a._v("是否有界：")])]),a._v(" "),r("p",[a._v("如果无界，就代表容量非常大。")]),a._v(" "),r("h3",{attrs:{id:"_2-阻塞队列的重要方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-阻塞队列的重要方法"}},[a._v("#")]),a._v(" 2.阻塞队列的重要方法")]),a._v(" "),r("ul",[r("li",[a._v("**"),r("code",[a._v("put")]),a._v(","),r("code",[a._v("take")]),a._v("：**特点是会阻塞")]),a._v(" "),r("li",[a._v("**"),r("code",[a._v("add")]),a._v(","),r("code",[a._v("remove")]),a._v(","),r("code",[a._v("element")]),a._v("：**功能差不多，区别就是它不会阻塞，而是抛出异常。"),r("code",[a._v("element")]),a._v("作用是返回队列头元素，没有也会抛出异常。")]),a._v(" "),r("li",[a._v("**"),r("code",[a._v("offer")]),a._v(","),r("code",[a._v("poll")]),a._v(","),r("code",[a._v("peek")]),a._v("：**这个比上面好一点，如果取不出来或添加不进去或者查看不了，会返回一个"),r("code",[a._v("null")]),a._v("。")])]),a._v(" "),r("h3",{attrs:{id:"_3-arrayblockingqueue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-arrayblockingqueue"}},[a._v("#")]),a._v(" 3.ArrayBlockingQueue")]),a._v(" "),r("ul",[r("li",[a._v("这是最常见的一种用法。")]),a._v(" "),r("li",[a._v("它是有界的，可以指定容量。")]),a._v(" "),r("li",[a._v("**公平：**可以指定是否需要保证公平。如果保证公平，等待了最长时间的线程会得到优先处理。不过同时也会带来性能损耗。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);