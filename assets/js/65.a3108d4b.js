(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{546:function(t,a,_){"use strict";_.r(a);var s=_(4),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"_1-lock接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-lock接口"}},[t._v("#")]),t._v(" 1.Lock接口")]),t._v(" "),_("ul",[_("li",[t._v("锁是一种工具，用来控制对共享资源的访问。")]),t._v(" "),_("li",[_("code",[t._v("Lock")]),t._v("是对"),_("code",[t._v("synchronized")]),t._v("的补充，提升。不是代替。")]),t._v(" "),_("li",[t._v("Lock接口最常见的实现类是"),_("code",[t._v("ReentrantLock")]),t._v("。")])]),t._v(" "),_("h3",{attrs:{id:"_1-1-为什么synchronized不够用？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-为什么synchronized不够用？"}},[t._v("#")]),t._v(" 1-1.为什么synchronized不够用？")]),t._v(" "),_("ul",[_("li",[t._v("**效率低。**锁的释放情况少，试图获得锁时不能设定超时。不能中断一个正在试图获得锁的线程。")]),t._v(" "),_("li",[t._v("**不够灵活。**比如读写锁就更加灵活。")]),t._v(" "),_("li",[t._v("无法知道是否成功获取到锁。")])]),t._v(" "),_("h2",{attrs:{id:"_2-lock主要方法介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-lock主要方法介绍"}},[t._v("#")]),t._v(" 2.Lock主要方法介绍")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("Lock接口声明了4个方法来获取锁。")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("lock()")])]),t._v(" "),_("li",[_("code",[t._v("tryLock()")])]),t._v(" "),_("li",[_("code",[t._v("tryLock(long time, TimeUnit unit)")])]),t._v(" "),_("li",[_("code",[t._v("lockInterruptibly()")])])])])]),t._v(" "),_("h3",{attrs:{id:"lock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lock"}},[t._v("#")]),t._v(" lock()")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("最普通的获取锁方法，如果锁已被其他线程获取则等待。")])]),t._v(" "),_("li",[_("p",[t._v("Lock不会像synchronized一样在异常时自动释放锁。")])]),t._v(" "),_("li",[_("p",[t._v("最佳解决方式就是使用"),_("code",[t._v("try-finally")]),t._v("，保证发生异常时锁一定会被释放。")])]),t._v(" "),_("li",[_("p",[_("code",[t._v("lock()")]),t._v("方法不能被中断，这会带来很大的隐患：一旦陷入死锁，"),_("code",[t._v("lock()")]),t._v("就会陷入无尽的等待。所以这里就会引出"),_("code",[t._v("tryLock()")]),t._v("方法。")])])]),t._v(" "),_("h3",{attrs:{id:"trylock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#trylock"}},[t._v("#")]),t._v(" tryLock()")]),t._v(" "),_("ul",[_("li",[t._v("该方法用来尝试获取锁，如果当前锁没有被占用，则获取成功，返回true，反之返回false。")]),t._v(" "),_("li",[t._v("该方法会立即返回，不会拿不到锁就一直在那等。")]),t._v(" "),_("li",[t._v("该方法显然功能更强大，可以根据是否获取到锁来决定程序后续的行为。")])]),t._v(" "),_("h3",{attrs:{id:"trylock-long-time-timeunit-unit"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#trylock-long-time-timeunit-unit"}},[t._v("#")]),t._v(" tryLock(long time, TimeUnit unit)")]),t._v(" "),_("ul",[_("li",[t._v("超时就放弃，它会等一段时间。")])]),t._v(" "),_("h3",{attrs:{id:"lockinterruptibly"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lockinterruptibly"}},[t._v("#")]),t._v(" lockInterruptibly()")]),t._v(" "),_("ul",[_("li",[t._v("相当于把"),_("code",[t._v("tryLock(long time, TimeUnit unit)")]),t._v("的超时时间设置为无限。在等待锁的过程中，线程可以被中断。")])]),t._v(" "),_("h2",{attrs:{id:"_3-锁的可见性保证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-锁的可见性保证"}},[t._v("#")]),t._v(" 3.锁的可见性保证")]),t._v(" "),_("ul",[_("li",[t._v("遵守happens-before原则")]),t._v(" "),_("li",[t._v("Lock的加解锁和synchronized有同样的内存语义。也就是说，下一个线程加锁后能看到所有前一个线程解锁前发生的所有事情。")])]),t._v(" "),_("h2",{attrs:{id:"_4-锁的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-锁的分类"}},[t._v("#")]),t._v(" 4.锁的分类")]),t._v(" "),_("ul",[_("li",[t._v("这些分类是从不同角度去看的，意思就是并非互斥的，一把锁可能属于多个分类的锁。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://bee71-1302549720.cos.ap-shanghai.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200804155916.png",alt:""}})]),t._v(" "),_("h3",{attrs:{id:"_3-1-悲观锁和乐观锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-悲观锁和乐观锁"}},[t._v("#")]),t._v(" 3-1.悲观锁和乐观锁")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("悲观锁的劣势：")])]),t._v(" "),_("ul",[_("li",[t._v("阻塞和唤醒带来的性能问题。")]),t._v(" "),_("li",[t._v("永久阻塞：持有锁的线程如果永久阻塞，那么其他线程永远得不到执行。")]),t._v(" "),_("li",[t._v("优先级反转：低优先级的线程拿到锁以后，如果一直不释放。优先级就错乱了。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("悲观锁：")])]),t._v(" "),_("ul",[_("li",[t._v("例子：Lock接口和synchronized关键字")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("乐观锁：")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("认为自己操作时不会有其他线程来干扰，所以并不会锁住被操作对象。")])]),t._v(" "),_("li",[_("p",[t._v("更新的时候，会去对比在修改期间数据有没有被其他线程动过，如果没被改变，就正常修改数据。")])]),t._v(" "),_("li",[_("p",[t._v("如果数据被改变，就会采取报错，放弃等策略。")])]),t._v(" "),_("li",[_("p",[t._v("用CAS算法来实现。")])]),t._v(" "),_("li",[_("p",[t._v("例子：原子类和并发容器等。")]),t._v(" "),_("div",{staticClass:"language-markdown line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-markdown"}},[_("code",[t._v("乐观锁的典型例子：git\n\n往远端仓库push的时候，会检查本地仓库和远程仓库的版本号是否一致。不一样就代表有人修改过了，这次提交就失败。\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br")])])])])]),t._v(" "),_("li",[_("p",[t._v("两种锁的各自使用场景：")]),t._v(" "),_("ul",[_("li",[t._v("**悲观锁：**适合并发写入多的情况。适用于临界区持有锁时间比较长的情况，可以避免大量无用的自旋等消耗。\n"),_("ul",[_("li",[t._v("1.临界区有IO操作。")]),t._v(" "),_("li",[t._v("2.临界区代码复杂或者循环量大。")]),t._v(" "),_("li",[t._v("3.临界区竞争非常激烈。")])])]),t._v(" "),_("li",[t._v("**乐观锁：**适合并发写入少，大多都是读取的场景。能让读取性能大大提高。")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-2-可重入锁和非可重入锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-可重入锁和非可重入锁"}},[t._v("#")]),t._v(" 3-2.可重入锁和非可重入锁")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("以"),_("code",[t._v("ReentrantLock")]),t._v("为例。")])]),t._v(" "),_("li",[_("h2",{attrs:{id:"可重入的性质："}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可重入的性质："}},[t._v("#")]),t._v(" 可重入的性质：")])])]),t._v(" "),_("h3",{attrs:{id:"_3-3-公平锁与非公平锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-公平锁与非公平锁"}},[t._v("#")]),t._v(" 3-3.公平锁与非公平锁")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("公平指的是完全按照线程请求的顺序来获取锁。非公平是指在一定情况下，可以插队。（合适的时机插队）")])]),t._v(" "),_("li",[_("p",[t._v("这样设计的目的是为了提高效率。避免唤醒带来的空档期。")]),t._v(" "),_("div",{staticClass:"language-markdown line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-markdown"}},[_("code",[t._v("比如有3个线程A，B，C\n\nA持有锁，A要释放锁，B就从阻塞状态中唤醒，唤醒是有开销和耗时的。\n而C这是突然来请求锁，它一直处于唤醒状态。\n这是双赢的局面，C请求到了,B唤醒也是耗时的，等C释放了，B正好完全唤醒。\n\n可以有效得提高吞吐量。\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-4-共享锁和独占锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-共享锁和独占锁"}},[t._v("#")]),t._v(" 3-4.共享锁和独占锁")]),t._v(" "),_("ul",[_("li",[t._v("共享锁又称为读锁，可以查看但无法修改或删除。可以多个线程同时获取到读锁。")]),t._v(" "),_("li",[t._v("典型案例："),_("code",[t._v("ReentrantReadWriteLock")]),t._v("。读锁是共享锁，写锁是独占锁。")]),t._v(" "),_("li",[t._v("没有读写锁之前，假设使用"),_("code",[t._v("ReentrantLock")]),t._v("，虽然保证了线程安全，但也浪费了一定的资源。读操作同时进行是没有线程安全问题的。")])]),t._v(" "),_("hr"),t._v(" "),_("ul",[_("li",[t._v("读写锁的规则")])]),t._v(" "),_("div",{staticClass:"language-markdown line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-markdown"}},[_("code",[_("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("1.")]),t._v(" 多个线程申请读锁，都可以申请到。\n"),_("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("2.")]),t._v(" 如果一个线程持有读锁，此时其他线程要申请写锁，就得等待读锁释放。\n"),_("span",{pre:!0,attrs:{class:"token list punctuation"}},[t._v("3.")]),t._v(" 如果一个线程占有了写锁，此时\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br")])]),_("h3",{attrs:{id:"_3-5-自旋锁和阻塞锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-自旋锁和阻塞锁"}},[t._v("#")]),t._v(" 3-5.自旋锁和阻塞锁")])])}),[],!1,null,null,null);a.default=v.exports}}]);