(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{555:function(v,_,t){"use strict";t.r(_);var a=t(4),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"tcp的三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp的三次握手"}},[v._v("#")]),v._v(" TCP的三次握手")]),v._v(" "),t("h2",{attrs:{id:"什么是三次握手？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是三次握手？"}},[v._v("#")]),v._v(" 什么是三次握手？")]),v._v(" "),t("p",[v._v("为了准确无误地把数据发送到目标处，TCP采用了三次握手的策略。简而言之，三次握手就是用来建立连接的。")]),v._v(" "),t("p",[v._v("那么三次握手双方都说了什么呢?")]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("A：喂，听得到吗？我的数据从序号x开始编号（SYN）")])]),v._v(" "),t("p",[t("strong",[v._v("B：好的，我知道了，我的数据从序号y开始编号（SYN-ACK）")])]),v._v(" "),t("p",[t("strong",[v._v("A：好的，我知道了，我们开始通话吧（ACK）")])])]),v._v(" "),t("p",[v._v("所以说，三次握手的过程中，不是你能不能听得到，而是协商双方开始的序号。\n"),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://bee71-1302549720.cos.ap-shanghai.myqcloud.com/1592881017898-78b2fa7a-55da-41aa-af2c-8cc227614235 (1).jpg"}})]),v._v(" "),t("ul",[t("li",[v._v("首先客户端发送一个SYN报文段，这个报文只有SYN被置1。另外这个报文是不携带数据的，但是它占用一个序号，意味着下次发送数据序列号要加一。客户端会随机生成一个序列号。")])]),v._v(" "),t("blockquote",[t("p",[v._v("为什么SYN要占用一个序列号呢？")]),v._v(" "),t("p",[v._v("​\t\t不占用序列号的段是不需要确认的。它里面都没内容你还确认个啥？比如ACK段。SYN段是需要对方确认的，所以要占一个序列号。")])]),v._v(" "),t("ul",[t("li",[v._v("服务端收到客户端的SYN的报文以后，将SYN+ACK都置位，发送给客户端。SYN的作用也是同步告知服务端生成的初始序号。ACK的作用是告知客户端你发送的SYN已经收到了，并指定下一个数据段的起始序号是多少。虽然也没有携带数据,但因为SYN需要被确认，所以也要占用一个序列号。")]),v._v(" "),t("li",[v._v("客户端最后发送一个ACK段。这个段用来确认服务端发送的SYN段。因为这个ACK段不携带任何数据，也不需要被确认，所以不占用序列号。")])]),v._v(" "),t("h2",{attrs:{id:"为什么是3次？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么是3次？"}},[v._v("#")]),v._v(" 为什么是3次？")]),v._v(" "),t("p",[v._v("协商一个序号的过程按理说需要一个来回来完成，也就是2次。所以理论上建立连接需要2个来回（4次），互相确认双方的初始序号（Initial Sequence Number，ISN）。\n但是第二个来回的告知和上一次的确认可以合在一起发送（SYN + ACK），所以只需要三次握手，就可以建立TCP连接。\n这也解释了为什么不能只有 2 次握手：因为只能协商一个序号。")]),v._v(" "),t("p",[v._v("在日常应用场景中，丢包率不高，因此三次握手是最合理的做法，少了不够，多了白搭。")]),v._v(" "),t("h2",{attrs:{id:"丢包了怎么办？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#丢包了怎么办？"}},[v._v("#")]),v._v(" 丢包了怎么办？")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("SYN+ACK丢包的话，发送方在等待超时后重传SYN包即可解决。")])]),v._v(" "),t("li",[t("p",[v._v("ACK丢包的话：")]),v._v(" "),t("ul",[t("li",[v._v("对A来说，如果接着有数据要发，由于在A看起来连接已经确认，A可以立即发出下一个数据包。这个数据包中也有ACK和SN,B收到后就能成功确立连接。")]),v._v(" "),t("li",[v._v("对B来说，如果一直没收到ACK，那么SYN+ACK这个包的计时器会超时，那么就会主动重传。知道收到A的ACK。如果重传多次后还是没有收到，就会停止尝试，并关闭TCP连接。")])])])]),v._v(" "),t("h2",{attrs:{id:"三次握手的状态变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手的状态变化"}},[v._v("#")]),v._v(" 三次握手的状态变化")]),v._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://bee71-1302549720.cos.ap-shanghai.myqcloud.com/1592904863816-fb8f17ad-2302-4a77-9bb6-bab14c13aeb9.jpg"}}),v._v("\n**对于客户端而言：**\n"),t("ul",[t("li",[v._v("初始的状态是处于 "),t("code",[v._v("ClOSED")]),v._v(" 状态。这里的 "),t("code",[v._v("ClOSED")]),v._v(" 不是一个真实的状态，而是一个假想的起点和终点。")]),v._v(" "),t("li",[v._v("客户端调用connect以后会发送SYN同步报文给服务端，然后进入 "),t("code",[v._v("SYN-SENT")]),v._v(" 状态，客户端将保持这个状态，直到它收到服务端的确认包。")]),v._v(" "),t("li",[v._v("在 "),t("code",[v._v("SYN-SENT")]),v._v(" 状态下，收到了服务端的确认包。客户端将发送服务端FIN报文的确认包，，同时进入 "),t("code",[v._v("ESTABLISHED")]),v._v(" 状态。表明自己准备好发送数据。")])]),v._v(" "),t("p",[t("strong",[v._v("对于服务端而言：")])]),v._v(" "),t("ul",[t("li",[v._v("初始状态同样是 "),t("code",[v._v("CLOSED")]),v._v(" 状态。")]),v._v(" "),t("li",[v._v("在执行bind，listen之后，进入 "),t("code",[v._v("LISTEN")]),v._v(" 状态。等待客户端的连接。")]),v._v(" "),t("li",[v._v("收到客户端的SYN报文以后，会回复确认并发送自己的SYN报文，之后会进入 "),t("code",[v._v("SYN-RCVD")]),v._v(" 状态等待确认。")]),v._v(" "),t("li",[v._v("收到客户端的确认报文以后，进入 "),t("code",[v._v("ESTABLISHED")]),v._v(" 状态，这时双方就可以互相发送数据了。")])])])}),[],!1,null,null,null);_.default=e.exports}}]);